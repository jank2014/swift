//: Playground - noun: a place where people can play
//made by jankz jankz@jankz.com
import UIKit
/************************************** 类和结构体 ****************************************/
print("类和结构体是人们构建代码所用的一种通用且灵活的构造体。我们可以使用完全相同的语法规则来为类和结构体定义属性(常量、变量)和添加方法,从而扩展类和结构体的功能。")
print("与其他编程语言所不同的是,Swift 并不要求你为自定义类和结构去创建独立的接口和实现文件。你所要做的是 在一个单一文件中定义一个类或者结构体,系统将会动生成面向其它代码的外部接口。")


/************************************** 类和结构体对比 ****************************************/
print("Swift 中类和结构体有很多共同点。共同处在于:")

/*

    • 定义属性用于存储值
    • 定义方法用于提供功能
    • 定义附属脚本用于访问值
    • 定义构造器用于生成初始化值
    • 通过扩展以增加默认实现的功能 • 实现协议以提供某种标准功能

*/

print("与结构体相比,类还有如下的附加功能:")

/*

    • 继承允许一个类继承另一个类的特征
    • 类型转换允许在运行时检查和解释一个类实例的类型 • 解构器允许一个类实例释放任何其所被分配的资源
    • 引用计数允许对一个类的多次引用

*/



/************************************** 定义语法 ****************************************/

print("类和结构体有着类似的定义方式。通过关键字class struct 来分别表示类和结构体 并在一对大括号中定义他们的具体内容")

print("类的定义")
/*
    class SomeClass {
        //class definition goes here 类主体代码
    }

*/

print("结构体定义")
/*
    struct SomeClass {
        //class definition goes here 类主体代码
    }

*/

//注意
//在你每次定义一个新类或者结构体的时候,实际上你是定义了一个新的 Swift 类型。
//因此请使用UpperCameCase 这种方式来命名(如 SomeClass 和 SomeStructure 等),以便符合标准 Swift 类型的大写命名风格(如 g , Int 和 Bool )。
//相反的,请使用 lowerCamelCase 这种方式为属性和方法命名(如 framerate 和 Count ),以便和类型名区分。



print("类和结构体定义示例")
struct Resolution {
    var width = 0
    var height = 0
}

class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}



/************************************** 类和结构体实例 ****************************************/

let someReolution = Resolution()
let someVideoMode = VideoMode()


/*

    结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号,
    如 Resolution() 或 VideoMode() 。通过这种方式所创建的类或者结构体实例,其属性均会被初始化为 默认值。

*/





/************************************** 属性访问 ****************************************/

//通过使用点语法(dot syntax),你可以访问实例的属性。其语法规则是,实例名后面紧跟属性名,两者通过点号( . )连接

someReolution.height
someReolution.width
someVideoMode.resolution.width

someVideoMode.resolution.width = 1280
print(someVideoMode.resolution.width)

/************************************** 类和结构体的成员逐一构造器 *********************************/

print("所有结构体都有一个自动生成的成员逐一构造器,用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中:")

let vga = Resolution(width: 640, height: 480)

print("与结构体不同,类实例没有默认的成员逐一构造器.")






/************************************** 结构体和枚举是值类型 ****************************************/

print("类型被赋予给一个变量、常量或者被传递给一个函数的时候,其值会被拷贝。")
/*

    在 Swift 中,所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary),都是 值类型,并且在底层都是以结构体的形式所实现。

*/

let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
/*

    在以上示例中,声明了一个名为hd的常量,其值为一个初始化为全高清视频分辨率(1920 像素宽,1080 像 素高)的 Resolution 实例。
    然后示例中又声明了一个名为 cinema 的变量,并将 hd 赋值给它。因为 Resolution 是一个结构体,所以 的值其实是 hd 的一个拷贝副本,而不是 hd 本身。
    尽管 hd 和 cinema 有着相同的宽(width)和高(heigh t),但是在幕后它们是两个完全不同的实例。

*/

cinema.width = 2048
print("cinema  now width is \(cinema.width)")

print("hd  now width is \(hd.width)")

/*

    在将 hd 赋予给 cinema 的时候,实际上是将 hd 中所存储的值进行拷贝,然后将拷贝的数据存储到新的 cinema 实 例中。
    结果就是两个完全独立的实例碰巧包含有相同的数值。由于两者相互独立,因此将 cinema 的 width 修改为2048 并不会影响 hd 中的 width 的值。

*/


/************************************** 类是引用类型 ****************************************/
print("与值类型不同,引用类型在被赋予到一个变量、常量或者被传递到一个函数时,其值不会被拷贝。因此,引用的是已存在的实例本身而不是其拷贝。")

let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0


let alsoTenEighty = tenEighty

alsoTenEighty.frameRate = 30.0

print("tenEighty frameRate is \(tenEighty.frameRate)")  //这里显示30 说明类是引用类型 不是值类型

/*

    需要注意的是 tenEighty 和 alsoTenEighty 被声明为常量而不是变量。
    然而你依然可以改变 tenEighty.frameRate 和 alsoTenEighty.frameRate ,因为 tenEighty 和 alsoTenEighty 这两个常量的值并未改变。
    它们并不“存储”这 个 VideoMode 实例,而仅仅是对 VideoMode 实例的引用。
    所以,改变的是被引用的 VideoMode 的 frameRate 属 性,而不是引用 VideoMode 的常量的值。

*/


print("恒等运算符")
/*

    因为类是引用类型,有可能有多个常量和变量在幕后同时引用同一个类实例。(对于结构体和枚举来说,这并不成立。
    因为它们作为值类型,在被赋予到常量、变量或者传递到函数时,其值总是会被拷贝。)
    如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的,Swift 内建了两个恒 等运算符:
    • 等价于(===)
    • 不等价于( !== )


*/
print("运用这两个运算符检测两个常量或者变量是否引用同一个实例")
if tenEighty === alsoTenEighty {
    print("===")
} else {
    print("!==")
}



/************************************** 类和结构体的选择 ****************************************/
print("然而,结构体实例总是通过值传递,类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候,你需要决定每个数据结构是定义成类还是结构体。")

print("按照通用的准则,当符合一条或多条以下条件时,请考虑构建结构体:")

/*

    • 该数据结构的主要目的是用来封装少量相关简单数据值。
    • 有理由预计该数据结构的实例在被赋值或传递时,封装的数据将会被拷贝而不是被引用。
    • 该数据结构中储存的值类型属性,也应该被拷贝,而不是被引用。
    • 该数据结构不需要去继承另一个既有类型的属性或者行为。


//eg:
    • 几何形状的大小,封装一个 width 属性和 height 属性,两者均为 Double 类型。
    • 一定范围内的路径,封装一个 start 属性和 length 属性,两者均为 Int 类型。
    • 三维坐标系内一点,封装 x , y 和 z 属性,三者均为 Double 类型。
*/

//定义一个类,生成一个它的实例,并通过引用来管理和传递。实际中,这意味着绝大部分的自定义数据构造都应该是类,而非结构体。



/************************************** 字符串数组 ****************************************/



/*

    Swift 中,许多基本类型,诸如 String , Array 和 Dictionary 类型均以结构体的形式实现。
    这意味着被赋值给 新的常量或变量,或者被传入函数或方法中时,它们的值会被拷贝。

    Objective-C 中 NSString , NSArray 和 NSDictionary 类型均以类的形式实现,而并非结构体。
    它们在被赋值或 者被传入函数或方法时,不会发生值拷贝,而是传递现有实例的引用。

*/

/*
    以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中,拷贝行为看起来似乎总会发生。
    然而,Sw ift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化,所以你没必要去回 避赋值来保证性能最优化。

*/



/************************************** 类是引用类型 ****************************************/










